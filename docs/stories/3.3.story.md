# Story 3.3: Update and Delete Products

## Status

**Done** ✅

## Story

**As a** user,  
**I want** to update product prices and delete products,  
**so that** I can maintain an accurate product catalog.

## Acceptance Criteria

1. [x] `update-product "<name>" <new_price>` command updates existing product price
2. [x] Update validates new price (numeric, non-negative)
3. [x] Update displays confirmation with old and new price
4. [x] Update command exits code 0 on success, 1 if not found, 2 if invalid price
5. [x] `delete-product "<name>"` command removes product from database
6. [x] Delete asks for confirmation before removing
7. [x] Delete displays confirmation message after removal
8. [x] Delete command exits code 0 on success, 1 if not found
9. [x] Unit tests for update/delete operations
10. [x] Integration tests for both commands
11. [x] All existing 193 tests still passing
12. [x] README.md updated with update/delete examples

## Tasks / Subtasks

- [x] **Task 1: Implement Product.update Method** (AC: 1, 2)
  - [x] Add `update_price(name, new_price)` class method
  - [x] Validate new price (numeric, >= 0)
  - [x] Find product by name
  - [x] Update price and updated_at timestamp
  - [x] Return updated product instance
  - [x] Raise appropriate errors (not found, invalid price)

- [x] **Task 2: Implement Product.delete Method** (AC: 5)
  - [x] Add `delete(name)` class method
  - [x] Find product by name
  - [x] Delete from database
  - [x] Return deleted product instance
  - [x] Raise ProductNotFoundError if not found

- [x] **Task 3: Implement update-product CLI Command** (AC: 1, 2, 3, 4)
  - [x] Add `execute_update_product` method to CLI
  - [x] Parse arguments (name, new_price)
  - [x] Validate arguments
  - [x] Call Product.update_price
  - [x] Display old price → new price confirmation
  - [x] Handle errors with appropriate exit codes

- [x] **Task 4: Implement delete-product CLI Command** (AC: 5, 6, 7, 8)
  - [x] Add `execute_delete_product` method to CLI
  - [x] Parse product name argument
  - [x] Fetch product to show details
  - [x] Ask for confirmation ("Are you sure? (y/n)")
  - [x] Delete if confirmed
  - [x] Display confirmation message
  - [x] Handle errors with appropriate exit codes

- [x] **Task 5: Update CLI Routing** (AC: 1, 5)
  - [x] Add `update-product` case to command router
  - [x] Add `delete-product` case to command router
  - [x] Update help text with new commands

- [x] **Task 6: Write Unit Tests** (AC: 9)
  - [x] Product.update_price tests
    - [x] Update with valid price
    - [x] Update updates timestamp
    - [x] Product not found error
    - [x] Invalid price validation
  - [x] Product.delete tests
    - [x] Delete existing product
    - [x] Delete returns deleted product
    - [x] Product not found error

- [x] **Task 7: Write Integration Tests** (AC: 10)
  - [x] update-product command tests
    - [x] Successful update with confirmation
    - [x] Update not found (exit 1)
    - [x] Invalid price (exit 2)
    - [x] Missing arguments (exit 1)
  - [x] delete-product command tests
    - [x] Successful delete with confirmation
    - [x] Delete not found (exit 1)
    - [x] Missing name argument (exit 1)
    - [x] Confirmation prompt behavior

- [x] **Task 8: Update Documentation** (AC: 12)
  - [x] Add update-product examples to README
  - [x] Add delete-product examples to README
  - [x] Update help text

- [x] **Task 9: Quality Verification** (AC: 11)
  - [x] Run full test suite (193 examples passing!)
  - [x] Run RuboCop (0 offenses)
  - [x] Manual testing of both commands
  - [x] Verify no regressions

## Expected Outcomes

- **Test Count:** ~205-210 examples (194 current + 11-16 new tests)
- **Coverage:** 78-80%
- **RuboCop:** 0 offenses
- **LOC Added:** ~120 lines (80 implementation + 40 tests)

## Implementation Notes

### Product.update_price Method
```ruby
def self.update_price(name, new_price)
  validate_price!(new_price)
  
  product = find_by_name(name)
  raise ProductNotFoundError, "Product '#{name}' not found" if product.nil?
  
  Database.connection.execute(
    'UPDATE products SET price = ?, updated_at = CURRENT_TIMESTAMP WHERE name = ? COLLATE NOCASE',
    [new_price.to_f, name]
  )
  
  find_by_name(name)
end
```

### Product.delete Method
```ruby
def self.delete(name)
  product = find_by_name(name)
  raise ProductNotFoundError, "Product '#{name}' not found" if product.nil?
  
  Database.connection.execute(
    'DELETE FROM products WHERE name = ? COLLATE NOCASE',
    [name]
  )
  
  product
end
```

### CLI update-product Example
```ruby
def execute_update_product
  unless storage_available?
    handle_storage_unavailable
    exit 1
  end
  
  name = @args[1]
  new_price = @args[2]
  
  # Validate arguments
  if name.nil? || name.strip.empty?
    warn_with_fallback('Product name required')
    exit 1
  end
  
  if new_price.nil?
    warn_with_fallback('New price required')
    exit 1
  end
  
  require_relative 'storage/product'
  
  # Get old price
  product = PocketKnife::Storage::Product.find_by_name(name)
  if product.nil?
    warn_with_fallback("Product '#{name}' not found")
    exit 1
  end
  
  old_price = product.formatted_price
  
  # Update price
  updated_product = PocketKnife::Storage::Product.update_price(name, new_price)
  
  puts "✓ Product price updated"
  puts "  Product: #{updated_product.name}"
  puts "  Old Price: #{old_price}"
  puts "  New Price: #{updated_product.formatted_price}"
rescue InvalidInputError => e
  warn_with_fallback(e.message)
  exit 2
end
```

### CLI delete-product Example
```ruby
def execute_delete_product
  unless storage_available?
    handle_storage_unavailable
    exit 1
  end
  
  name = @args[1]
  
  if name.nil? || name.strip.empty?
    warn_with_fallback('Product name required')
    exit 1
  end
  
  require_relative 'storage/product'
  
  product = PocketKnife::Storage::Product.find_by_name(name)
  if product.nil?
    warn_with_fallback("Product '#{name}' not found")
    exit 1
  end
  
  # Ask for confirmation
  puts "Delete product '#{product.name}' (#{product.formatted_price})?"
  print "Are you sure? (y/n): "
  response = $stdin.gets.chomp.downcase
  
  unless response == 'y' || response == 'yes'
    puts "Deletion cancelled"
    exit 0
  end
  
  PocketKnife::Storage::Product.delete(name)
  
  puts "✓ Product deleted successfully"
  puts "  Name: #{product.name}"
  puts "  Price: #{product.formatted_price}"
end
```

## Estimated Effort

**Time:** 2-3 hours  
**Complexity:** Medium (confirmation prompts, validation)

## Definition of Done

- [ ] All 12 acceptance criteria met
- [ ] 11-16 integration/unit tests written and passing
- [ ] Total test suite ~205-210 examples, 0 failures
- [ ] RuboCop: 0 offenses
- [ ] Code coverage: 78%+
- [ ] README.md updated
- [ ] Help text updated
- [ ] Manual testing completed
- [ ] No regressions
