# Story 3.3: Update and Delete Products

## Status

**In Progress** ðŸš§

## Story

**As a** user,  
**I want** to update product prices and delete products,  
**so that** I can maintain an accurate product catalog.

## Acceptance Criteria

1. [ ] `update-product "<name>" <new_price>` command updates existing product price
2. [ ] Update validates new price (numeric, non-negative)
3. [ ] Update displays confirmation with old and new price
4. [ ] Update command exits code 0 on success, 1 if not found, 2 if invalid price
5. [ ] `delete-product "<name>"` command removes product from database
6. [ ] Delete asks for confirmation before removing
7. [ ] Delete displays confirmation message after removal
8. [ ] Delete command exits code 0 on success, 1 if not found
9. [ ] Unit tests for update/delete operations
10. [ ] Integration tests for both commands
11. [ ] All existing tests still passing
12. [ ] README.md updated with update/delete examples

## Tasks / Subtasks

- [ ] **Task 1: Implement Product.update Method** (AC: 1, 2)
  - [ ] Add `update_price(name, new_price)` class method
  - [ ] Validate new price (numeric, >= 0)
  - [ ] Find product by name
  - [ ] Update price and updated_at timestamp
  - [ ] Return updated product instance
  - [ ] Raise appropriate errors (not found, invalid price)

- [ ] **Task 2: Implement Product.delete Method** (AC: 5)
  - [ ] Add `delete(name)` class method
  - [ ] Find product by name
  - [ ] Delete from database
  - [ ] Return deleted product instance
  - [ ] Raise ProductNotFoundError if not found

- [ ] **Task 3: Implement update-product CLI Command** (AC: 1, 2, 3, 4)
  - [ ] Add `execute_update_product` method to CLI
  - [ ] Parse arguments (name, new_price)
  - [ ] Validate arguments
  - [ ] Call Product.update_price
  - [ ] Display old price â†’ new price confirmation
  - [ ] Handle errors with appropriate exit codes

- [ ] **Task 4: Implement delete-product CLI Command** (AC: 5, 6, 7, 8)
  - [ ] Add `execute_delete_product` method to CLI
  - [ ] Parse product name argument
  - [ ] Fetch product to show details
  - [ ] Ask for confirmation ("Are you sure? (y/n)")
  - [ ] Delete if confirmed
  - [ ] Display confirmation message
  - [ ] Handle errors with appropriate exit codes

- [ ] **Task 5: Update CLI Routing** (AC: 1, 5)
  - [ ] Add `update-product` case to command router
  - [ ] Add `delete-product` case to command router
  - [ ] Update help text with new commands

- [ ] **Task 6: Write Unit Tests** (AC: 9)
  - [ ] Product.update_price tests
    - [ ] Update with valid price
    - [ ] Update updates timestamp
    - [ ] Product not found error
    - [ ] Invalid price validation
  - [ ] Product.delete tests
    - [ ] Delete existing product
    - [ ] Delete returns deleted product
    - [ ] Product not found error

- [ ] **Task 7: Write Integration Tests** (AC: 10)
  - [ ] update-product command tests
    - [ ] Successful update with confirmation
    - [ ] Update not found (exit 1)
    - [ ] Invalid price (exit 2)
    - [ ] Missing arguments (exit 1)
  - [ ] delete-product command tests
    - [ ] Successful delete with confirmation
    - [ ] Delete not found (exit 1)
    - [ ] Missing name argument (exit 1)
    - [ ] Confirmation prompt behavior

- [ ] **Task 8: Update Documentation** (AC: 12)
  - [ ] Add update-product examples to README
  - [ ] Add delete-product examples to README
  - [ ] Update help text

- [ ] **Task 9: Quality Verification** (AC: 11)
  - [ ] Run full test suite (expect ~205-210 examples)
  - [ ] Run RuboCop (0 offenses)
  - [ ] Manual testing of both commands
  - [ ] Verify no regressions

## Expected Outcomes

- **Test Count:** ~205-210 examples (194 current + 11-16 new tests)
- **Coverage:** 78-80%
- **RuboCop:** 0 offenses
- **LOC Added:** ~120 lines (80 implementation + 40 tests)

## Implementation Notes

### Product.update_price Method
```ruby
def self.update_price(name, new_price)
  validate_price!(new_price)
  
  product = find_by_name(name)
  raise ProductNotFoundError, "Product '#{name}' not found" if product.nil?
  
  Database.connection.execute(
    'UPDATE products SET price = ?, updated_at = CURRENT_TIMESTAMP WHERE name = ? COLLATE NOCASE',
    [new_price.to_f, name]
  )
  
  find_by_name(name)
end
```

### Product.delete Method
```ruby
def self.delete(name)
  product = find_by_name(name)
  raise ProductNotFoundError, "Product '#{name}' not found" if product.nil?
  
  Database.connection.execute(
    'DELETE FROM products WHERE name = ? COLLATE NOCASE',
    [name]
  )
  
  product
end
```

### CLI update-product Example
```ruby
def execute_update_product
  unless storage_available?
    handle_storage_unavailable
    exit 1
  end
  
  name = @args[1]
  new_price = @args[2]
  
  # Validate arguments
  if name.nil? || name.strip.empty?
    warn_with_fallback('Product name required')
    exit 1
  end
  
  if new_price.nil?
    warn_with_fallback('New price required')
    exit 1
  end
  
  require_relative 'storage/product'
  
  # Get old price
  product = PocketKnife::Storage::Product.find_by_name(name)
  if product.nil?
    warn_with_fallback("Product '#{name}' not found")
    exit 1
  end
  
  old_price = product.formatted_price
  
  # Update price
  updated_product = PocketKnife::Storage::Product.update_price(name, new_price)
  
  puts "âœ“ Product price updated"
  puts "  Product: #{updated_product.name}"
  puts "  Old Price: #{old_price}"
  puts "  New Price: #{updated_product.formatted_price}"
rescue InvalidInputError => e
  warn_with_fallback(e.message)
  exit 2
end
```

### CLI delete-product Example
```ruby
def execute_delete_product
  unless storage_available?
    handle_storage_unavailable
    exit 1
  end
  
  name = @args[1]
  
  if name.nil? || name.strip.empty?
    warn_with_fallback('Product name required')
    exit 1
  end
  
  require_relative 'storage/product'
  
  product = PocketKnife::Storage::Product.find_by_name(name)
  if product.nil?
    warn_with_fallback("Product '#{name}' not found")
    exit 1
  end
  
  # Ask for confirmation
  puts "Delete product '#{product.name}' (#{product.formatted_price})?"
  print "Are you sure? (y/n): "
  response = $stdin.gets.chomp.downcase
  
  unless response == 'y' || response == 'yes'
    puts "Deletion cancelled"
    exit 0
  end
  
  PocketKnife::Storage::Product.delete(name)
  
  puts "âœ“ Product deleted successfully"
  puts "  Name: #{product.name}"
  puts "  Price: #{product.formatted_price}"
end
```

## Estimated Effort

**Time:** 2-3 hours  
**Complexity:** Medium (confirmation prompts, validation)

## Definition of Done

- [ ] All 12 acceptance criteria met
- [ ] 11-16 integration/unit tests written and passing
- [ ] Total test suite ~205-210 examples, 0 failures
- [ ] RuboCop: 0 offenses
- [ ] Code coverage: 78%+
- [ ] README.md updated
- [ ] Help text updated
- [ ] Manual testing completed
- [ ] No regressions
