# Story 4.2: Extend Product Model with Query Methods - Brownfield Addition

**Epic:** Natural Language Product Query Interface (EPIC-4)  
**Story ID:** PROD-QUERY-2  
**Status:** Done ✅  
**Estimate:** 3-4 hours  
**Priority:** High (Required for Story 4.1 & 4.3)

---

## User Story

As a **pocket-knife developer**,  
I want **Product model extended with price filtering and query methods**,  
So that **the ProductQueryTool can execute sophisticated product searches from natural language queries**.

---

## Story Context

### Existing System Integration

- **Integrates with:** Existing `Product` model (`lib/pocket_knife/storage/product.rb`)
- **Technology:** Ruby 3.2+, SQLite3 database, Active Record patterns
- **Follows pattern:** Existing Product class methods (`.find_by_name`, `.all`, `.exists?`)
- **Touch points:** 
  - `lib/pocket_knife/storage/product.rb` (extend existing class)
  - `lib/pocket_knife/storage/database.rb` (existing database connection)
  - Existing products table schema (no changes needed)
  - Unit tests in `spec/unit/storage/product_spec.rb`

---

## Acceptance Criteria

**Total:** 11 acceptance criteria

### Functional Requirements

- [x] 1. **Method: filter_by_max_price**
   - Class method added: `Product.filter_by_max_price(max_price)`
   - Parameters:
     - `max_price` (numeric, required): Maximum price threshold
   - Returns array of Product instances where `price <= max_price`
   - Results ordered by price ascending, then name ascending
   - Returns empty array if no matches
   - Validates max_price is a valid number (converts to float)
   - Raises `InvalidInputError` if max_price is negative
   - Raises `InvalidInputError` if max_price is not numeric

- [x] 2. **Method: filter_by_price_range**
   - Class method added: `Product.filter_by_price_range(min_price, max_price)`
   - Parameters:
     - `min_price` (numeric, required): Minimum price (inclusive)
     - `max_price` (numeric, required): Maximum price (inclusive)
   - Returns array of Product instances where `min_price <= price <= max_price`
   - Results ordered by price ascending, then name ascending
   - Returns empty array if no matches
   - Validates both prices are valid numbers
   - Raises `InvalidInputError` if min_price > max_price
   - Raises `InvalidInputError` if either price is negative
   - Raises `InvalidInputError` if either price is not numeric

- [x] 3. **Method: count**
   - Class method added: `Product.count`
   - Parameters: none
   - Returns integer count of all products in database
   - Returns 0 if no products exist
   - Efficient SQL COUNT query (not loading all records)

- [x] 4. **SQL Query Safety**
   - All queries use parameterized SQL statements
   - No string interpolation in SQL queries
   - Protection against SQL injection
   - Proper use of SQLite3 bindings with `?` placeholders

### Integration Requirements

- [x] 5. **Existing Product Methods Unchanged**
   - `.create(name, price)` - unchanged
   - `.find_by_name(name)` - unchanged
   - `.all` - unchanged
   - `.exists?(name)` - unchanged
   - `.update_price(name, new_price)` - unchanged
   - `.delete(name)` - unchanged
   - All existing unit tests pass without modification

- [x] 6. **Database Schema Unchanged**
   - No migrations required
   - Uses existing products table structure
   - No new indexes needed (query performance acceptable for MVP)
   - Compatible with existing data

- [x] 7. **Error Handling Consistency**
   - Uses existing error classes from `lib/pocket_knife/errors.rb`
   - Error messages follow existing patterns
   - Validation logic matches existing validation style

- [x] 8. **Existing Patterns Followed**
   - Private validation methods pattern (e.g., `validate_price!`)
   - Class method definitions in `class << self` block
   - Return type consistency (arrays of Product instances)
   - SQL query patterns match existing methods

### Quality Requirements

- [x] 9. **Unit Tests Extended**
   - Extend `spec/unit/storage/product_spec.rb`
   - New describe block: `describe '.filter_by_max_price'`
   - New describe block: `describe '.filter_by_price_range'`
   - New describe block: `describe '.count'`
   - Test scenarios for each method:
     - Happy path with results
     - No results (empty array)
     - Edge cases (exact matches, boundaries)
     - Invalid inputs (validation errors)
     - Multiple results (ordering verification)
   - Minimum 25 new test cases total
   - 100% coverage for new methods

- [x] 10. **Integration Tests Extended**
    - Extend `spec/integration/storage_cli_spec.rb` (if needed for future CLI)
    - Verify methods work with real database
    - Test data persistence and querying
    - Verify ordering of results

- [x] 11. **No Regressions**
    - All existing Product tests pass (35 existing tests)
    - All existing storage tests pass (19 database tests)
    - All integration tests pass (8 CLI tests)
    - Total test suite still passes (185+ tests)
    - Test coverage remains at 80%+
    - RuboCop passes with 0 offenses

---

## Dev Notes

### CRITICAL Pre-Implementation Verification

**⚠️ MUST VERIFY BEFORE CODING:**

1. **Existing Product Model Structure**
   ```ruby
   # File: lib/pocket_knife/storage/product.rb
   # Review lines 20-100 to understand:
   # - Existing class method patterns in `class << self` block
   # - Validation method patterns (validate_name!, validate_price!)
   # - SQL query patterns with parameterization
   # - Return type patterns (Product instances vs arrays)
   ```
   
   **ACTION:** Open `lib/pocket_knife/storage/product.rb` and locate the `class << self` block (around line 18). Add new methods in this block following the same pattern as `.all` method.

2. **Database Connection Pattern**
   ```ruby
   # Existing connection usage:
   Database.connection.execute('SELECT * FROM products WHERE ..., [params])
   # Returns array of row hashes with string keys: row['id'], row['name'], row['price']
   ```
   
   **ACTION:** Review `.find_by_name` (line 30-44) and `.all` (line 46-58) to see how to use `Database.connection` and map rows to Product instances.

3. **Existing Validation Pattern**
   ```ruby
   # File: lib/pocket_knife/storage/product.rb, lines 88-97
   # private
   # def validate_name!(name)
   #   raise InvalidInputError, 'message' if condition
   # end
   ```
   
   **ACTION:** Add new private validation methods for price filtering following this pattern.

### Implementation Strategy

**Phase 1: Add Validation Methods (30 min)**
1. Add `validate_numeric_price!(price, name)` private method
2. Add `validate_price_range!(min_price, max_price)` private method
3. Keep validation consistent with existing `validate_price!` method

**Phase 2: Implement filter_by_max_price (1 hour)**
1. Add method in `class << self` block
2. Validate input parameter
3. Write parameterized SQL query with WHERE clause
4. Execute query and map to Product instances
5. Add ordering (ORDER BY price ASC, name ASC)

**Phase 3: Implement filter_by_price_range (1 hour)**
1. Add method in `class << self` block
2. Validate input parameters (both prices + range logic)
3. Write parameterized SQL query with BETWEEN or WHERE clauses
4. Execute query and map to Product instances
5. Add ordering (ORDER BY price ASC, name ASC)

**Phase 4: Implement count (15 min)**
1. Add method in `class << self` block
2. Write SQL COUNT query
3. Return integer result

**Phase 5: Testing (1.5-2 hours)**
1. Add describe blocks to existing test file
2. Write comprehensive test cases for each method
3. Test edge cases and error conditions
4. Verify ordering of results
5. Run full test suite to ensure no regressions

### SQL Query Examples

**filter_by_max_price:**
```ruby
# Use parameterized query
sql = 'SELECT * FROM products WHERE price <= ? ORDER BY price ASC, name ASC'
rows = Database.connection.execute(sql, [max_price.to_f])
```

**filter_by_price_range:**
```ruby
# Option 1: BETWEEN clause
sql = 'SELECT * FROM products WHERE price BETWEEN ? AND ? ORDER BY price ASC, name ASC'
rows = Database.connection.execute(sql, [min_price.to_f, max_price.to_f])

# Option 2: WHERE with AND (more explicit)
sql = 'SELECT * FROM products WHERE price >= ? AND price <= ? ORDER BY price ASC, name ASC'
rows = Database.connection.execute(sql, [min_price.to_f, max_price.to_f])
```

**count:**
```ruby
sql = 'SELECT COUNT(*) as count FROM products'
result = Database.connection.get_first_row(sql)
result['count'].to_i
```

### Result Mapping Pattern

**Follow existing `.all` method pattern:**
```ruby
rows = Database.connection.execute(sql, params)
rows.map do |row|
  new(
    id: row['id'],
    name: row['name'],
    price: row['price'],
    created_at: row['created_at'],
    updated_at: row['updated_at']
  )
end
```

### Validation Logic

**validate_numeric_price! (new private method):**
```ruby
def validate_numeric_price!(price, param_name = 'price')
  price_f = Float(price)
  raise InvalidInputError, "#{param_name} must be non-negative" if price_f.negative?
  price_f
rescue ArgumentError
  raise InvalidInputError, "#{param_name} must be a numeric value"
end
```

**validate_price_range! (new private method):**
```ruby
def validate_price_range!(min_price, max_price)
  min_f = validate_numeric_price!(min_price, 'min_price')
  max_f = validate_numeric_price!(max_price, 'max_price')
  
  if min_f > max_f
    raise InvalidInputError, 'min_price cannot be greater than max_price'
  end
  
  [min_f, max_f]
end
```

---

## Test Coverage Requirements

### Minimum Test Scenarios

**filter_by_max_price (10 tests):**
1. Returns products under max price
2. Returns products exactly at max price (boundary)
3. Returns empty array when no products under max
4. Orders results by price ascending
5. Orders results by name when prices equal
6. Accepts integer max_price
7. Accepts float max_price
8. Raises error for negative max_price
9. Raises error for non-numeric max_price
10. Handles empty database

**filter_by_price_range (12 tests):**
1. Returns products within range
2. Includes products at min boundary (inclusive)
3. Includes products at max boundary (inclusive)
4. Returns empty array when no products in range
5. Orders results by price ascending
6. Orders results by name when prices equal
7. Accepts integer prices
8. Accepts float prices
9. Raises error when min > max
10. Raises error for negative min_price
11. Raises error for negative max_price
12. Raises error for non-numeric prices

**count (3 tests):**
1. Returns correct count when products exist
2. Returns 0 when database is empty
3. Returns integer type

### Test Data Setup

**Use existing test setup patterns:**
```ruby
# Create test products with varied prices
Product.create('Cheap Item', 1.99)
Product.create('Medium Item', 10.00)
Product.create('Expensive Item', 99.99)
Product.create('Another Medium', 10.00)  # For ordering tests
```

---

## Definition of Done

- [x] `Product.filter_by_max_price(max_price)` method implemented
- [x] `Product.filter_by_price_range(min_price, max_price)` method implemented
- [x] `Product.count` method implemented
- [x] All SQL queries use parameterized statements
- [x] Input validation prevents invalid queries
- [x] Results are properly ordered (price ASC, name ASC)
- [x] Private validation methods added
- [x] 25+ new unit tests added to `spec/unit/storage/product_spec.rb`
- [x] All new tests pass
- [x] All existing tests pass (no regressions)
- [x] Test coverage >80% maintained
- [x] RuboCop passes (0 offenses)
- [x] Code follows existing patterns and conventions
- [x] No database schema changes required

---

## Story Dependencies

**Depends on:**
- Story 3.1 (Product Storage Foundation) - ✅ Completed

**Blocks:**
- Story 4.3 (Implement ask-product CLI) - Partial dependency
- Story 4.1 (Product Query Tool) - Provides methods used by tool

**Works in Parallel With:**
- Story 4.1 (Product Query Tool) - Can develop simultaneously with stubbing

---

## Integration Notes

### For Story 4.1 Integration

Once this story is complete:
1. Update Story 4.1 tests to remove stubs for `filter_by_max_price` and `filter_by_price_range`
2. Convert Story 4.1 tests to integration tests using real Product methods
3. Verify ProductQueryTool works with actual database queries

### For Story 4.3 Integration

These methods will be called by ProductQueryTool, which is invoked by the `ask-product` CLI command:
```
User Query → ask-product CLI → RubyLLM → ProductQueryTool → Product.filter_by_*() → SQLite
```

---

## Performance Considerations

**Query Complexity:**
- All queries are simple WHERE clauses on indexed column (price)
- No joins or complex aggregations
- Expected result sets: < 100 products (typical user database)
- Performance: < 10ms for queries with current scope

**Future Optimization (Out of Scope):**
- Add index on price column if database grows > 1000 products
- Consider pagination for very large result sets
- Add LIMIT clause if LLM responses get too long

---

## Notes

This story extends the Product model with the foundation for natural language querying. Keep methods simple and focused on single responsibilities. The ordering (price ASC, name ASC) ensures consistent, predictable results that are user-friendly when displayed by the CLI.

Focus on maintaining the existing code quality and patterns. This is a brownfield addition, so consistency with existing code is critical for maintainability.
