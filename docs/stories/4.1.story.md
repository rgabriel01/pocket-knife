# Story 4.1: Product Query Tool with LLM Function Definitions - Brownfield Addition

**Epic:** Natural Language Product Query Interface (EPIC-4)  
**Story ID:** PROD-QUERY-1  
**Estimate:** 4-5 hours  
**Priority:** High (Foundation for Epic)

---

## User Story

As a **pocket-knife developer**,  
I want **a ProductQueryTool that defines product database operations as RubyLLM function tools**,  
So that **the LLM can interpret natural language queries and execute appropriate product database operations**.

---

## Story Context

### Existing System Integration

- **Integrates with:** `Product` model (`lib/pocket_knife/storage/product.rb`)
- **Technology:** Ruby 3.2+, RubyLLM gem, SQLite3 database
- **Follows pattern:** `PercentageCalculatorTool` pattern (inherits from `RubyLLM::Tool`)
- **Touch points:** 
  - `lib/pocket_knife/storage/product.rb` (existing Product model with CRUD operations)
  - `lib/pocket_knife/llm_config.rb` (existing LLM configuration)
  - `lib/pocket_knife.rb` (main module require file)
  - New tool file for product query operations

---

## Acceptance Criteria

**Total:** 11 acceptance criteria

### Functional Requirements

- [x] 1. **ProductQueryTool Class Created**
   - New `lib/pocket_knife/product_query_tool.rb` file created
   - Inherits from `RubyLLM::Tool`
   - Namespaced under `PocketKnife::`
   - Follows frozen string literal convention
   - Clear class-level documentation

- [x] 2. **Function Tool: Find Product by Name**
   - Tool name: `find_product_by_name`
   - Description: "Search for a product by its exact name"
   - Parameters:
     - `name` (string, required): "The product name to search for"
   - `execute` method calls `Product.find_by_name(name)`
   - Returns formatted response:
     - If found: "Product found: [name] - $[price]"
     - If not found: "No product found with name '[name]'"
   - Handles nil/empty name gracefully

- [x] 3. **Function Tool: List All Products**
   - Tool name: `list_all_products`
   - Description: "Get a complete list of all stored products"
   - Parameters: none
   - `execute` method calls `Product.all`
   - Returns formatted response:
     - If products exist: "Found [count] products:\n1. [name] - $[price]\n2. ..."
     - If no products: "No products stored in the database"
   - Lists products in name order (alphabetically)

- [x] 4. **Function Tool: Filter Products by Max Price**
   - Tool name: `filter_products_by_max_price`
   - Description: "Find all products priced at or below a maximum price"
   - Parameters:
     - `max_price` (number, required): "Maximum price threshold (products <= this value)"
   - `execute` method calls `Product.filter_by_max_price(max_price)` (NEW method - see Story 4.2)
   - Returns formatted response:
     - If found: "Found [count] products under $[max]:\n1. [name] - $[price]\n..."
     - If none: "No products found priced at or under $[max]"
   - Validates max_price is positive number

- [x] 5. **Function Tool: Filter Products by Price Range**
   - Tool name: `filter_products_by_price_range`
   - Description: "Find all products within a specific price range"
   - Parameters:
     - `min_price` (number, required): "Minimum price (inclusive)"
     - `max_price` (number, required): "Maximum price (inclusive)"
   - `execute` method calls `Product.filter_by_price_range(min_price, max_price)` (NEW method - see Story 4.2)
   - Returns formatted response:
     - If found: "Found [count] products between $[min] and $[max]:\n1. [name] - $[price]\n..."
     - If none: "No products found in price range $[min] - $[max]"
   - Validates min_price <= max_price

### Integration Requirements

- [x] 6. **Existing Product Model Unchanged (for this story)**
   - Product model remains unchanged in this story
   - New query methods will be added in Story 4.2
   - Tool uses existing methods: `find_by_name`, `all`
   - Tool calls to new methods (`filter_by_max_price`, `filter_by_price_range`) will be implemented after Story 4.2

- [x] 7. **Error Handling**
   - Gracefully handles `ProductNotFoundError` (converts to user-friendly message)
   - Handles invalid price inputs (negative, non-numeric)
   - Handles database connection errors (provides helpful message)
   - Handles storage not available (suggests running with `--with storage`)

- [x] 8. **Existing Patterns Followed**
   - Ruby style guide compliance (Rubocop passes)
   - Module namespacing under `PocketKnife::`
   - Frozen string literals at top of files
   - Documentation comments for all public methods
   - Parameter validation patterns match `PercentageCalculatorTool`

### Quality Requirements

- [x] 9. **Unit Tests Created**
   - New `spec/unit/product_query_tool_spec.rb`
   - Tests for each function tool definition (4 tools)
   - Tests successful execution for each tool
   - Tests error handling:
     - Product not found
     - Invalid price inputs
     - Empty database
     - Storage not available
   - Mock `Product` model methods
   - Mock `RubyLLM::Tool` parent class
   - 100% code coverage for ProductQueryTool class

- [x] 10. **Documentation Added**
    - Class-level documentation explaining tool purpose
    - Each function tool has clear description
    - Parameter descriptions are detailed and helpful for LLM
    - Example usage in comments
    - Integration notes for developers

- [x] 11. **No Regressions**
    - All existing tests pass (unit, integration, e2e)
    - `pocket-knife ask` command still works
    - `pocket-knife store-product` command still works
    - Test coverage remains at 80%+

---

## Dev Notes

### CRITICAL Pre-Implementation Verification

**⚠️ MUST VERIFY BEFORE CODING:**

1. **PercentageCalculatorTool Pattern Review**
   ```ruby
   # File: lib/pocket_knife/percentage_calculator_tool.rb
   # Review the structure to match:
   # - Class inheritance from RubyLLM::Tool
   # - Tool name and description format
   # - Parameter definition syntax
   # - Execute method signature and return format
   ```
   
   **ACTION:** Open `lib/pocket_knife/percentage_calculator_tool.rb` and use it as the template for ProductQueryTool structure.

2. **Product Model Method Review**
   ```ruby
   # Current Product methods (verify in lib/pocket_knife/storage/product.rb):
   # - Product.find_by_name(name) → Product instance or nil
   # - Product.all → Array of Product instances
   # - Product.exists?(name) → Boolean
   # 
   # NEW methods needed (Story 4.2):
   # - Product.filter_by_max_price(max_price) → Array of Product instances
   # - Product.filter_by_price_range(min_price, max_price) → Array of Product instances
   ```
   
   **ACTION:** For this story, implement function tools that will call the new methods. Use stubbing in tests until Story 4.2 is complete.

3. **Product Instance Attributes**
   ```ruby
   # Verify Product instance has these attributes:
   # - @id (integer)
   # - @name (string)
   # - @price (float)
   # - @created_at (timestamp)
   # - @updated_at (timestamp)
   ```
   
   **ACTION:** Review `lib/pocket_knife/storage/product.rb` line 8-10 to confirm attributes for formatting output.

### Implementation Strategy

**Phase 1: Tool Structure (1 hour)**
1. Create `lib/pocket_knife/product_query_tool.rb`
2. Set up class inheritance and module structure
3. Add class-level documentation

**Phase 2: Function Tools (2 hours)**
1. Implement `find_product_by_name` tool
2. Implement `list_all_products` tool
3. Implement `filter_products_by_max_price` tool (calls method from Story 4.2)
4. Implement `filter_products_by_price_range` tool (calls method from Story 4.2)
5. Add response formatting helper methods

**Phase 3: Error Handling (1 hour)**
1. Add input validation for price parameters
2. Add error handling for database errors
3. Add graceful degradation for missing storage
4. Test error scenarios

**Phase 4: Testing (1-2 hours)**
1. Create test file with RSpec structure
2. Write tests for each function tool
3. Write error handling tests
4. Verify 100% coverage
5. Run full test suite

### Response Formatting Guidelines

**Consistency:**
- Always include product count in responses ("Found X products")
- Format prices consistently with $ symbol and 2 decimal places
- Use numbered lists for multiple products (1., 2., 3., ...)
- Keep messages concise but informative

**Examples:**
```ruby
# Single product found
"Product found: Banana - $1.99"

# Multiple products
"Found 3 products under $5.00:
1. Apple - $1.50
2. Banana - $1.99
3. Orange - $2.99"

# No results
"No products found with name 'Mango'"
```

### Dependency Note

**Story 4.2 Dependency:**
- Function tools `filter_products_by_max_price` and `filter_products_by_price_range` will call methods that don't exist yet
- This is acceptable - implement the tool definitions now
- Tests will stub these methods until Story 4.2 completes
- Once Story 4.2 is done, update tests to integration tests with real methods

### RubyLLM Tool API Reference

**Key Methods to Implement:**
```ruby
class ProductQueryTool < RubyLLM::Tool
  # Define tool name and description
  tool_name "product_query"
  description "Query product database with natural language"
  
  # Define functions
  function :find_product_by_name do
    description "Search for a product by name"
    param :name, type: :string, required: true, description: "Product name"
  end
  
  def find_product_by_name(name:)
    # Implementation
  end
end
```

**ACTION:** Verify exact syntax by reviewing `PercentageCalculatorTool` implementation.

---

## Test Coverage Requirements

**Minimum Test Scenarios:**

1. **find_product_by_name:**
   - Product exists → returns formatted message
   - Product not found → returns not found message
   - Empty name → returns error message
   - Nil name → returns error message

2. **list_all_products:**
   - Products exist → returns formatted list
   - No products → returns empty message
   - Single product → formats correctly
   - Multiple products → formats with numbering

3. **filter_products_by_max_price:**
   - Products found under max → returns formatted list
   - No products under max → returns no results message
   - Invalid max_price (negative) → returns error
   - max_price = 0 → handles edge case

4. **filter_products_by_price_range:**
   - Products in range → returns formatted list
   - No products in range → returns no results message
   - min > max → returns error message
   - Negative values → returns error

5. **Error Handling:**
   - Database connection error → helpful message
   - Storage not available → installation instructions
   - Product model raises exception → graceful handling

---

## Definition of Done

- [x] ProductQueryTool class created in `lib/pocket_knife/product_query_tool.rb`
- [x] All 4 function tools implemented with proper parameters
- [x] Response formatting is consistent and user-friendly
- [x] Input validation prevents invalid queries
- [x] Error handling is comprehensive
- [x] Unit tests created with 100% coverage
- [x] All tests pass (new and existing)
- [x] RuboCop passes (0 offenses)
- [x] Code follows existing patterns and conventions
- [x] Documentation is clear and complete
- [x] Ready to integrate with Story 4.2 (Product model extensions)

---

## Story Dependencies

**Depends on:**
- Story 3.1 (Product Storage Foundation) - ✅ Completed
- LLM Story 1 (RubyLLM Integration) - ✅ Completed

**Blocks:**
- Story 4.2 (Extend Product Model) - Partial dependency (can work in parallel)
- Story 4.3 (Implement ask-product CLI) - Must complete before 4.3

**Works in Parallel With:**
- Story 4.2 (both stories can be developed simultaneously)

---

## Notes

This story establishes the LLM tool interface for product queries. The actual query methods will be added to the Product model in Story 4.2. Tests should stub the new Product methods (`filter_by_max_price`, `filter_by_price_range`) until Story 4.2 is complete, then update to integration tests.

Focus on creating a clean, well-documented tool interface that the LLM can easily understand and use to interpret natural language queries about products.
